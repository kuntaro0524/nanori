#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PlateCodes
==========
General-purpose mapper from *film/drawing* coordinates (in mm) to *machine stage* coordinates (in pulses),
calibrated from **three** anchor wells with known machine coordinates.

- Supports a standard 8x12 plate: rows A..H (8), columns 1..12.
- Drawing geometry (mm): x along columns (1..12), y along rows (A..H)
  x_mm = offset_x + pitch_x*(col-1)
  y_mm = offset_y + pitch_y*(row-1)

- Calibration: provide exactly 3 anchors as {well_label: (SX_pulse, Y1_pulse)}.
  The wells can be *any* three non-collinear positions (e.g., A1, H1, A7).

- Model: 2D affine transform (mm -> pulses). With 3 anchors, the affine is uniquely determined
  (provided the three source points in mm are not collinear). This captures offset, rotation,
  scaling (anisotropic allowed), and shear. It does NOT assume axes are aligned.

Example
-------
anchors = {
  "A1": (6760, 20930),
  "H1": (6760, 36680),
  "A7": (20260, 36680),
}
pc = PlateCodes(anchors=anchors)
sx, y1 = pc.getCodes("A7")
pc.to_csv("plate_pulses.csv")
"""

from dataclasses import dataclass
from typing import Dict, Tuple, Iterable, Optional
import re
import numpy as np
import pandas as pd

@dataclass
class PlateParams:
    n_rows: int = 8
    n_cols: int = 12
    pitch_x_mm: float = 9.0
    pitch_y_mm: float = 9.0
    offset_x_mm: float = 5.5
    offset_y_mm: float = 5.5
    pulses_per_mm: float = 250.0  # informational only

def _parse_well_label(well: str) -> Tuple[int, int]:
    """
    Parse 'A1'..'H12' into (row_idx, col_idx), 1-based.
    Row letters are case-insensitive.
    """
    if not isinstance(well, str):
        raise ValueError("well label must be a string like 'A1'")
    s = well.strip().upper()
    m = re.match(r'^([A-Z])\s*([0-9]+)$', s)
    if not m:
        raise ValueError(f"Invalid well label: {well}")
    row_letter, col_str = m.groups()
    row_idx = ord(row_letter) - ord('A') + 1
    col_idx = int(col_str)
    return row_idx, col_idx

def _well_label(row_idx: int, col_idx: int) -> str:
    return f"{chr(ord('A') + row_idx - 1)}{col_idx}"

def _well_mm(row_idx: int, col_idx: int, P: PlateParams) -> Tuple[float, float]:
    """
    Film/drawing coordinates in mm.
    x along columns (1..n_cols), y along rows (A..).
    """
    x = P.offset_x_mm + P.pitch_x_mm * (col_idx - 1)
    y = P.offset_y_mm + P.pitch_y_mm * (row_idx - 1)
    return x, y

class PlateCodes:
    def __init__(self,
                 anchors: Dict[str, Tuple[float, float]],
                 params: Optional[PlateParams] = None):
        """
        anchors: dict like {'A1': (SX_pulse, Y1_pulse), 'H1': (...), 'A7': (...)}
                 Exactly 3 wells required; must not be collinear in drawing (mm) space.
        params:  plate geometry parameters.
        """
        self.params = params or PlateParams()
        if len(anchors) != 3:
            raise ValueError("Provide exactly 3 anchor wells in 'anchors'.")
        # Normalize labels and store
        self.anchors = {k.strip().upper(): (float(v[0]), float(v[1])) for k, v in anchors.items()}
        # Build source (mm) and destination (pulse) for affine fit
        src_pts = []
        dst_pts = []
        for w, (sx, y1) in self.anchors.items():
            r, c = _parse_well_label(w)
            if not (1 <= r <= self.params.n_rows and 1 <= c <= self.params.n_cols):
                raise ValueError(f"Anchor '{w}' is out of plate bounds {self.params.n_rows}x{self.params.n_cols}.")
            x_mm, y_mm = _well_mm(r, c, self.params)
            src_pts.append([x_mm, y_mm])
            dst_pts.append([sx, y1])
        self.src_mm = np.asarray(src_pts, dtype=float)   # (3,2)
        self.dst_pulse = np.asarray(dst_pts, dtype=float)# (3,2)
        # Check collinearity of src points
        area2 = _triangle_area2(self.src_mm[0], self.src_mm[1], self.src_mm[2])
        if abs(area2) < 1e-9:
            raise ValueError("The three anchor wells are collinear in drawing space; affine fit is ill-posed.")
        # Fit affine (exact with 3 points)
        self.A = _fit_affine_2d(self.src_mm, self.dst_pulse)  # 2x3
        # Precompute the full table
        self._build_table()

    def _apply_affine(self, xy: np.ndarray) -> np.ndarray:
        xy1 = np.hstack([xy, np.ones((xy.shape[0], 1))])
        return xy1 @ self.A.T

    def _build_table(self):
        rows = []
        for r in range(1, self.params.n_rows+1):
            for c in range(1, self.params.n_cols+1):
                x_mm, y_mm = _well_mm(r, c, self.params)
                sx, y1 = self._apply_affine(np.array([[x_mm, y_mm]]))[0]
                rows.append({
                    "well": _well_label(r, c),
                    "row": chr(ord('A') + r - 1),
                    "col": c,
                    "X_mm": round(x_mm, 4),
                    "Y_mm": round(y_mm, 4),
                    "SX_pulse": float(sx),
                    "Y1_pulse": float(y1)
                })
        self.df = pd.DataFrame(rows, columns=["well","row","col","X_mm","Y_mm","SX_pulse","Y1_pulse"])
        self.map = {row["well"]: (row["SX_pulse"], row["Y1_pulse"]) for _, row in self.df.iterrows()}

    def getCodes(self, well: str) -> Tuple[float, float]:
        """Return (SX_pulse, Y1_pulse) for a given well like 'A7'. Raises KeyError if invalid."""
        key = well.strip().upper()
        if key not in self.map:
            # Validate format before raising for better message
            r, c = _parse_well_label(key)
            if not (1 <= r <= self.params.n_rows and 1 <= c <= self.params.n_cols):
                raise KeyError(f"Well {key} out of bounds {self.params.n_rows}x{self.params.n_cols}.")
            raise KeyError(f"Well {key} not found (unexpected).")
        return self.map[key]

    def to_dataframe(self) -> pd.DataFrame:
        return self.df.copy()

    def to_csv(self, path: str):
        self.df.to_csv(path, index=False)

    # Convenience: expose residuals on the three anchors
    def anchor_fit_report(self) -> pd.DataFrame:
        rows = []
        for (w, dst) in self.anchors.items():
            r, c = _parse_well_label(w)
            x_mm, y_mm = _well_mm(r, c, self.params)
            pred = self._apply_affine(np.array([[x_mm, y_mm]]))[0]
            rows.append({
                "well": w,
                "X_mm": x_mm, "Y_mm": y_mm,
                "SX_meas": dst[0], "Y1_meas": dst[1],
                "SX_fit": pred[0], "Y1_fit": pred[1],
                "SX_resid": dst[0]-pred[0], "Y1_resid": dst[1]-pred[1]
            })
        return pd.DataFrame(rows)

def _fit_affine_2d(src_xy: np.ndarray, dst_uv: np.ndarray) -> np.ndarray:
    """Least-squares 2D affine fit from src (N,2) to dst (N,2). Returns 2x3 matrix A."""
    N = src_xy.shape[0]
    X = np.hstack([src_xy, np.ones((N,1))])   # (N,3)
    U = dst_uv[:,0:1]
    V = dst_uv[:,1:2]
    Au, *_ = np.linalg.lstsq(X, U, rcond=None)  # (3,1)
    Av, *_ = np.linalg.lstsq(X, V, rcond=None)  # (3,1)
    A = np.vstack([Au.T, Av.T])  # (2,3)
    return A

def _triangle_area2(p, q, r) -> float:
    """Twice the signed area of triangle pqr (for collinearity check)."""
    return (q[0]-p[0])*(r[1]-p[1]) - (q[1]-p[1])*(r[0]-p[0])

if __name__ == "__main__":
    # Simple demo with the user's example anchors (A1, H1, A7)
    anchors = {"A1": (6760, 20930), "H1": (6760, 36680), "A7": (20260, 36680)}
    pc = PlateCodes(anchors=anchors)
    print("A7 codes:", pc.getCodes("A7"))
    #pc.to_csv("plate_codes_example.csv")
    #print("Wrote: plate_codes_example.csv")
